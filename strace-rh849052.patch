diff -rup a/defs.h b/defs.h
--- a/defs.h	2012-07-09 11:05:44.584569353 -0600
+++ b/defs.h	2012-07-09 11:06:06.455460558 -0600
@@ -318,6 +318,31 @@ extern int mp_ioctl (int f, int c, void
 # endif
 #endif
 
+#ifdef LINUX
+# ifndef PTRACE_SETOPTIONS
+#  define PTRACE_SETOPTIONS	0x4200
+# endif
+# ifndef PTRACE_O_TRACEFORK
+#  define PTRACE_O_TRACEFORK	0x00000002
+# endif
+# ifndef PTRACE_O_TRACEVFORK
+#  define PTRACE_O_TRACEVFORK	0x00000004
+# endif
+# ifndef PTRACE_O_TRACECLONE
+#  define PTRACE_O_TRACECLONE	0x00000008
+# endif
+
+# ifndef PTRACE_EVENT_FORK
+#  define PTRACE_EVENT_FORK	1
+# endif
+# ifndef PTRACE_EVENT_VFORK
+#  define PTRACE_EVENT_VFORK	2
+# endif
+# ifndef PTRACE_EVENT_CLONE
+#  define PTRACE_EVENT_CLONE	3
+# endif
+#endif /* LINUX */
+
 /* Trace Control Block */
 struct tcb {
 	short flags;		/* See below for TCB_ values */
@@ -476,6 +501,7 @@ extern const struct xlat open_access_mod
 extern struct tcb **tcbtab;
 extern int *qual_flags;
 extern int debug, followfork;
+extern unsigned int ptrace_setoptions;
 extern int dtime, cflag, xflag, qflag;
 extern int acolumn;
 extern unsigned int nprocs, tcbtabsize;
@@ -558,6 +584,10 @@ extern int internal_fork P((struct tcb *
 extern int internal_exec P((struct tcb *));
 extern int internal_wait P((struct tcb *, int));
 extern int internal_exit P((struct tcb *));
+#ifdef LINUX
+extern int handle_new_child(struct tcb *, int, int);
+#endif
+
 
 extern const struct ioctlent *ioctl_lookup P((long));
 extern const struct ioctlent *ioctl_next_match P((const struct ioctlent *));
diff -rup a/process.c b/process.c
--- a/process.c	2012-07-09 11:05:44.575569398 -0600
+++ b/process.c	2012-07-09 11:06:06.459460538 -0600
@@ -903,6 +903,12 @@ struct tcb *tcp;
 {
 	struct tcb *tcpchild;
 	int pid;
+
+        if ((ptrace_setoptions
+            & (PTRACE_O_TRACECLONE | PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK))
+           == (PTRACE_O_TRACECLONE | PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK))
+                return 0;
+
 	if (entering(tcp)) {
 		if (!followfork)
 			return 0;
@@ -928,109 +934,128 @@ struct tcb *tcp;
 
 		pid = tcp->u_rval;
 
+		return handle_new_child (tcp, pid, bpt);
+	}
+	return 0;
+}
+#endif
+
+#ifdef LINUX
+int
+handle_new_child(struct tcb *tcp, int pid, int bpt)
+{
+	struct tcb *tcpchild;
+
 #ifdef CLONE_PTRACE		/* See new setbpt code.  */
-		tcpchild = pid2tcb(pid);
-		if (tcpchild != NULL) {
-			/* The child already reported its startup trap
-			   before the parent reported its syscall return.  */
-			if ((tcpchild->flags
-			     & (TCB_STARTUP|TCB_ATTACHED|TCB_SUSPENDED))
-			    != (TCB_STARTUP|TCB_ATTACHED|TCB_SUSPENDED))
-				fprintf(stderr, "\
+	tcpchild = pid2tcb(pid);
+	if (tcpchild != NULL) {
+		/* The child already reported its startup trap
+		   before the parent reported its syscall return.  */
+		if ((tcpchild->flags
+		     & (TCB_STARTUP|TCB_ATTACHED|TCB_SUSPENDED))
+		    != (TCB_STARTUP|TCB_ATTACHED|TCB_SUSPENDED))
+			fprintf(stderr, "\
 [preattached child %d of %d in weird state!]\n",
-					pid, tcp->pid);
-		}
-		else
-#endif
-		{
-			fork_tcb(tcp);
-			tcpchild = alloctcb(pid);
-		}
+				pid, tcp->pid);
+	}
+	else
+#endif /* CLONE_PTRACE */
+	{
+		fork_tcb(tcp);
+		tcpchild = alloctcb(pid);
+	}
 
 #ifndef CLONE_PTRACE
-		/* Attach to the new child */
-		if (ptrace(PTRACE_ATTACH, pid, (char *) 1, 0) < 0) {
-			if (bpt)
-				clearbpt(tcp);
-			perror("PTRACE_ATTACH");
-			fprintf(stderr, "Too late?\n");
-			droptcb(tcpchild);
-			return 0;
-		}
-#endif
-
+	/* Attach to the new child */
+	if (ptrace(PTRACE_ATTACH, pid, (char *) 1, 0) < 0) {
 		if (bpt)
 			clearbpt(tcp);
+		perror("PTRACE_ATTACH");
+		fprintf(stderr, "Too late?\n");
+		droptcb(tcpchild);
+		return 0;
+	}
+#endif /* !CLONE_PTRACE */
 
-		tcpchild->flags |= TCB_ATTACHED;
-		/* Child has BPT too, must be removed on first occasion.  */
-		if (bpt) {
-			tcpchild->flags |= TCB_BPTSET;
-			tcpchild->baddr = tcp->baddr;
-			memcpy(tcpchild->inst, tcp->inst,
-				sizeof tcpchild->inst);
-		}
-		tcpchild->parent = tcp;
-		tcp->nchildren++;
-		if (tcpchild->flags & TCB_SUSPENDED) {
-			/* The child was born suspended, due to our having
-			   forced CLONE_PTRACE.  */
-			if (bpt)
-				clearbpt(tcpchild);
+	if (bpt)
+		clearbpt(tcp);
 
-			tcpchild->flags &= ~(TCB_SUSPENDED|TCB_STARTUP);
-			if (ptrace_restart(PTRACE_SYSCALL, tcpchild, 0) < 0)
-				return -1;
+	tcpchild->flags |= TCB_ATTACHED;
+	/* Child has BPT too, must be removed on first occasion.  */
+	if (bpt) {
+		tcpchild->flags |= TCB_BPTSET;
+		tcpchild->baddr = tcp->baddr;
+		memcpy(tcpchild->inst, tcp->inst,
+			sizeof tcpchild->inst);
+	}
+	tcpchild->parent = tcp;
+	tcp->nchildren++;
+	if (tcpchild->flags & TCB_SUSPENDED) {
+		/* The child was born suspended, due to our having
+		   forced CLONE_PTRACE.  */
+		if (bpt)
+			clearbpt(tcpchild);
 
-			if (!qflag)
-				fprintf(stderr, "\
+		tcpchild->flags &= ~(TCB_SUSPENDED|TCB_STARTUP);
+		if (ptrace_restart(PTRACE_SYSCALL, tcpchild, 0) < 0)
+			return -1;
+
+		if (!qflag)
+			fprintf(stderr, "\
 Process %u resumed (parent %d ready)\n",
-					pid, tcp->pid);
-		}
-		else {
-			if (!qflag)
-				fprintf(stderr, "Process %d attached\n", pid);
-		}
+				pid, tcp->pid);
+	}
+	else {
+		if (!qflag)
+			fprintf(stderr, "Process %d attached\n", pid);
+	}
 
 #ifdef TCB_CLONE_THREAD
-		{
-			/*
-			 * Save the flags used in this call,
-			 * in case we point TCP to our parent below.
-			 */
-			int call_flags = tcp->u_arg[ARG_FLAGS];
-			if ((tcp->flags & TCB_CLONE_THREAD) &&
-			    tcp->parent != NULL) {
-				/* The parent in this clone is itself a
-				   thread belonging to another process.
-				   There is no meaning to the parentage
-				   relationship of the new child with the
-				   thread, only with the process.  We
-				   associate the new thread with our
-				   parent.  Since this is done for every
-				   new thread, there will never be a
-				   TCB_CLONE_THREAD process that has
-				   children.  */
-				--tcp->nchildren;
+	if (sysent[tcp->scno].sys_func == sys_clone)
+	{
+		/*
+		 * Save the flags used in this call,
+		 * in case we point TCP to our parent below.
+		 */
+		int call_flags = tcp->u_arg[ARG_FLAGS];
+		if ((tcp->flags & TCB_CLONE_THREAD) &&
+		    tcp->parent != NULL) {
+			/* The parent in this clone is itself a
+			   thread belonging to another process.
+			   There is no meaning to the parentage
+			   relationship of the new child with the
+			   thread, only with the process.  We
+			   associate the new thread with our
+			   parent.  Since this is done for every
+			   new thread, there will never be a
+			   TCB_CLONE_THREAD process that has
+			   children.  */
+			--tcp->nchildren;
+			tcp = tcp->parent;
+			tcpchild->parent = tcp;
+			++tcp->nchildren;
+		}
+		if (call_flags & CLONE_THREAD) {
+			tcpchild->flags |= TCB_CLONE_THREAD;
+			++tcp->nclone_threads;
+		}
+		if ((call_flags & CLONE_PARENT) &&
+		    !(call_flags & CLONE_THREAD)) {
+			--tcp->nchildren;
+			tcpchild->parent = NULL;
+			if (tcp->parent != NULL) {
 				tcp = tcp->parent;
 				tcpchild->parent = tcp;
 				++tcp->nchildren;
 			}
-			if (call_flags & CLONE_THREAD) {
-				tcpchild->flags |= TCB_CLONE_THREAD;
-				++tcp->nclone_threads;
-			}
-			if (call_flags & CLONE_DETACHED) {
-				tcpchild->flags |= TCB_CLONE_DETACHED;
-				++tcp->nclone_detached;
-			}
 		}
-#endif
 	}
+#endif /* TCB_CLONE_THREAD */
 	return 0;
 }
 #endif
 
+
 int
 internal_fork(tcp)
 struct tcb *tcp;
diff -rup a/strace.c b/strace.c
--- a/strace.c	2012-07-09 11:05:44.568569433 -0600
+++ b/strace.c	2012-07-09 11:19:16.994478300 -0600
@@ -83,6 +83,7 @@ extern char *optarg;
 
 
 int debug = 0, followfork = 0;
+unsigned int ptrace_setoptions = 0;
 int dtime = 0, cflag = 0, xflag = 0, qflag = 0;
 static int iflag = 0, interactive = 0, pflag_seen = 0, rflag = 0, tflag = 0;
 /*
@@ -688,6 +689,77 @@ startup_child (char **argv)
 #endif /* USE_PROCFS */
 }
 
+#ifdef LINUX
+/*
+ * Test whether kernel support PTRACE_O_TRACECLONE et al options.
+ * First fork a new child, call ptrace with PTRACE_SETOPTIONS on it,
+ * and then see which options are supported on this kernel.
+ */
+static int
+test_ptrace_setoptions(void)
+{
+	int pid;
+
+	if ((pid = fork()) < 0)
+		return -1;
+	else if (pid == 0) {
+		if (ptrace(PTRACE_TRACEME, 0, (char *)1, 0) < 0) {
+			_exit(1);
+		}
+		kill(getpid(), SIGSTOP);
+		if ((pid = fork()) < 0) {
+			_exit(1);
+		}
+		_exit(0);
+	}
+	else {
+		int status, tracee_pid, error;
+		int no_child = 0;
+		while (1) {
+			tracee_pid = wait4(-1, &status, 0, NULL);
+			error = errno;
+			if (tracee_pid == -1) {
+				switch (error) {
+				case EINTR:
+					continue;
+				case ECHILD:
+					no_child = 1;
+					break;
+				default:
+					errno = error;
+					perror("test_ptrace_setoptions");
+					return -1;
+				}
+			}
+			if (no_child)
+				break;
+			if (tracee_pid != pid) {
+				if (ptrace(PTRACE_CONT, tracee_pid, 0, 0) < 0 &&
+				    errno != ESRCH)
+					kill(tracee_pid, SIGKILL);
+			}
+			else if (WIFSTOPPED(status)) {
+				if (status >> 16 == PTRACE_EVENT_FORK)
+					ptrace_setoptions |= (PTRACE_O_TRACEVFORK |
+							      PTRACE_O_TRACECLONE |
+							      PTRACE_O_TRACEFORK);
+				if (WSTOPSIG(status) == SIGSTOP) {
+					if (ptrace(PTRACE_SETOPTIONS, pid, NULL,
+						   PTRACE_O_TRACEFORK) < 0) {
+						kill(pid, SIGKILL);
+						return -1;
+					}
+				}
+				if (ptrace(PTRACE_SYSCALL, pid, 0, 0) < 0 &&
+				    errno != ESRCH)
+					kill(pid, SIGKILL);
+			}
+		}
+	}
+	return 0;
+}
+#endif
+
 int
 main(int argc, char *argv[])
 {
@@ -897,6 +969,15 @@ main(int argc, char *argv[])
 		interactive = 0;
 		qflag = 1;
 	}
+
+#ifdef LINUX
+	if (followfork && test_ptrace_setoptions() < 0) {
+		fprintf(stderr, "Test for options supported by PTRACE_SETOPTIONS\
+			failed, give up using this feature\n");
+		ptrace_setoptions = 0;
+	}
+#endif
+
 	/* Valid states here:
 	   optind < argc	pflag_seen	outfname	interactive
 	   1			0		0		1
@@ -2423,6 +2504,31 @@ Process %d attached (waiting for parent)
 	return found_tcps;
 }
 
+#ifdef LINUX
+static int
+handle_ptrace_event(int status, struct tcb *tcp)
+{
+	if (status >> 16 == PTRACE_EVENT_VFORK ||
+	    status >> 16 == PTRACE_EVENT_CLONE ||
+	    status >> 16 == PTRACE_EVENT_FORK) {
+		int childpid;
+
+		if (do_ptrace(PTRACE_GETEVENTMSG, tcp, NULL, &childpid) < 0) {
+			if (errno != ESRCH) {
+				fprintf(stderr, "\
+%s: handle_ptrace_event: ptrace cannot get new child's pid\n",
+					progname);
+				cleanup();
+				exit(1);
+			}
+			return -1;
+		}
+		return handle_new_child(tcp, childpid, 0);
+	}
+	return 1;
+}
+#endif
+
 static int
 handle_stopped_tcbs(struct tcb *tcp)
 {
@@ -2492,6 +2598,11 @@ handle_stopped_tcbs(struct tcb *tcp)
 			fprintf(stderr, "pid %u stopped, [%s]\n",
 				pid, signame(WSTOPSIG(status)));
 
+		if (ptrace_setoptions && (status >> 16)) {
+			if (handle_ptrace_event(status, tcp) != 1)
+				goto tracing;
+		}
+
 		/*
 		 * Interestingly, the process may stop
 		 * with STOPSIG equal to some other signal
@@ -2519,7 +2630,13 @@ handle_stopped_tcbs(struct tcb *tcp)
 					return -1;
 				}
 			}
-			set_ptrace_options(tcp);
+#ifdef LINUX
+                       if (followfork && (tcp->parent == NULL) && ptrace_setoptions)
+                               if (ptrace(PTRACE_SETOPTIONS, tcp->pid,
+                                          NULL, ptrace_setoptions | probe_ptrace_setoptions) < 0 &&
+                                   errno != ESRCH)
+                                       ptrace_setoptions = 0;
+#endif
 			goto tracing;
 		}
 
Only in a: strace.c.orig
